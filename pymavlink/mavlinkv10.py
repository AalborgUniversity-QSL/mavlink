'''
MAVLink protocol implementation (auto-generated by mavgen.py)

Generated from: quad_formation.xml,pixhawk.xml

Note: this file has been auto-generated. DO NOT EDIT
'''

import struct, array, time, json
from ...generator.mavcrc import x25crc

WIRE_PROTOCOL_VERSION = "1.0"


# some base types from mavlink_types.h
MAVLINK_TYPE_CHAR     = 0
MAVLINK_TYPE_UINT8_T  = 1
MAVLINK_TYPE_INT8_T   = 2
MAVLINK_TYPE_UINT16_T = 3
MAVLINK_TYPE_INT16_T  = 4
MAVLINK_TYPE_UINT32_T = 5
MAVLINK_TYPE_INT32_T  = 6
MAVLINK_TYPE_UINT64_T = 7
MAVLINK_TYPE_INT64_T  = 8
MAVLINK_TYPE_FLOAT    = 9
MAVLINK_TYPE_DOUBLE   = 10


class MAVLink_header(object):
    '''MAVLink message header'''
    def __init__(self, msgId, mlen=0, seq=0, srcSystem=0, srcComponent=0):
        self.mlen = mlen
        self.seq = seq
        self.srcSystem = srcSystem
        self.srcComponent = srcComponent
        self.msgId = msgId

    def pack(self):
        return struct.pack('BBBBBB', 254, self.mlen, self.seq,
                          self.srcSystem, self.srcComponent, self.msgId)

class MAVLink_message(object):
    '''base MAVLink message class'''
    def __init__(self, msgId, name):
        self._header     = MAVLink_header(msgId)
        self._payload    = None
        self._msgbuf     = None
        self._crc        = None
        self._fieldnames = []
        self._type       = name

    def get_msgbuf(self):
        if isinstance(self._msgbuf, str):
            return self._msgbuf
        return self._msgbuf.tostring()

    def get_header(self):
        return self._header

    def get_payload(self):
        return self._payload

    def get_crc(self):
        return self._crc

    def get_fieldnames(self):
        return self._fieldnames

    def get_type(self):
        return self._type

    def get_msgId(self):
        return self._header.msgId

    def get_srcSystem(self):
        return self._header.srcSystem

    def get_srcComponent(self):
        return self._header.srcComponent

    def get_seq(self):
        return self._header.seq

    def __str__(self):
        ret = '%s {' % self._type
        for a in self._fieldnames:
            v = getattr(self, a)
            ret += '%s : %s, ' % (a, v)
        ret = ret[0:-2] + '}'
        return ret

    def to_dict(self):
        d = dict({})
        d['mavpackettype'] = self._type
        for a in self._fieldnames:
          d[a] = getattr(self, a)
        return d

    def to_json(self):
        return json.dumps(self.to_dict())

    def pack(self, mav, crc_extra, payload):
        self._payload = payload
        self._header  = MAVLink_header(self._header.msgId, len(payload), mav.seq,
                                       mav.srcSystem, mav.srcComponent)
        self._msgbuf = self._header.pack() + payload
        crc = x25crc(self._msgbuf[1:])
        if True: # using CRC extra
            crc.accumulate(chr(crc_extra))
        self._crc = crc.crc
        self._msgbuf += struct.pack('<H', self._crc)
        return self._msgbuf


# enums

class EnumEntry(object):
    def __init__(self, name, description):
        self.name = name
        self.description = description
        self.param = {}
        
enums = {}

# DATA_TYPES
enums['DATA_TYPES'] = {}
DATA_TYPE_JPEG_IMAGE = 1 # 
enums['DATA_TYPES'][1] = EnumEntry('DATA_TYPE_JPEG_IMAGE', '''''')
DATA_TYPE_RAW_IMAGE = 2 # 
enums['DATA_TYPES'][2] = EnumEntry('DATA_TYPE_RAW_IMAGE', '''''')
DATA_TYPE_KINECT = 3 # 
enums['DATA_TYPES'][3] = EnumEntry('DATA_TYPE_KINECT', '''''')
DATA_TYPES_ENUM_END = 4 # 
enums['DATA_TYPES'][4] = EnumEntry('DATA_TYPES_ENUM_END', '''''')

# MAV_CMD
enums['MAV_CMD'] = {}
MAV_CMD_DO_START_SEARCH = 10001 # Starts a search
enums['MAV_CMD'][10001] = EnumEntry('MAV_CMD_DO_START_SEARCH', '''Starts a search''')
enums['MAV_CMD'][10001].param[1] = '''1 to arm, 0 to disarm'''
MAV_CMD_DO_FINISH_SEARCH = 10002 # Starts a search
enums['MAV_CMD'][10002] = EnumEntry('MAV_CMD_DO_FINISH_SEARCH', '''Starts a search''')
enums['MAV_CMD'][10002].param[1] = '''1 to arm, 0 to disarm'''
MAV_CMD_NAV_SWEEP = 10003 # Starts a search
enums['MAV_CMD'][10003] = EnumEntry('MAV_CMD_NAV_SWEEP', '''Starts a search''')
enums['MAV_CMD'][10003].param[1] = '''1 to arm, 0 to disarm'''
MAV_CMD_ENUM_END = 10004 # 
enums['MAV_CMD'][10004] = EnumEntry('MAV_CMD_ENUM_END', '''''')

# message IDs
MAVLINK_MSG_ID_BAD_DATA = -1
MAVLINK_MSG_ID_QUAD_POS = 199
MAVLINK_MSG_ID_SET_CAM_SHUTTER = 151
MAVLINK_MSG_ID_IMAGE_TRIGGERED = 152
MAVLINK_MSG_ID_IMAGE_TRIGGER_CONTROL = 153
MAVLINK_MSG_ID_IMAGE_AVAILABLE = 154
MAVLINK_MSG_ID_SET_POSITION_CONTROL_OFFSET = 160
MAVLINK_MSG_ID_POSITION_CONTROL_SETPOINT = 170
MAVLINK_MSG_ID_MARKER = 171
MAVLINK_MSG_ID_RAW_AUX = 172
MAVLINK_MSG_ID_WATCHDOG_HEARTBEAT = 180
MAVLINK_MSG_ID_WATCHDOG_PROCESS_INFO = 181
MAVLINK_MSG_ID_WATCHDOG_PROCESS_STATUS = 182
MAVLINK_MSG_ID_WATCHDOG_COMMAND = 183
MAVLINK_MSG_ID_PATTERN_DETECTED = 190
MAVLINK_MSG_ID_POINT_OF_INTEREST = 191
MAVLINK_MSG_ID_POINT_OF_INTEREST_CONNECTION = 192
MAVLINK_MSG_ID_BRIEF_FEATURE = 195
MAVLINK_MSG_ID_ATTITUDE_CONTROL = 200
MAVLINK_MSG_ID_DETECTION_STATS = 205
MAVLINK_MSG_ID_ONBOARD_HEALTH = 206

class MAVLink_quad_pos_message(MAVLink_message):
        '''
        Position of quadcopter in VICON space [pos_no,x,y,z]
        '''
        def __init__(self, pos_no, x, y, z):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_QUAD_POS, 'QUAD_POS')
                self._fieldnames = ['pos_no', 'x', 'y', 'z']
                self.pos_no = pos_no
                self.x = x
                self.y = y
                self.z = z

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 32, struct.pack('<hhhB', self.x, self.y, self.z, self.pos_no))

class MAVLink_set_cam_shutter_message(MAVLink_message):
        '''

        '''
        def __init__(self, cam_no, cam_mode, trigger_pin, interval, exposure, gain):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_SET_CAM_SHUTTER, 'SET_CAM_SHUTTER')
                self._fieldnames = ['cam_no', 'cam_mode', 'trigger_pin', 'interval', 'exposure', 'gain']
                self.cam_no = cam_no
                self.cam_mode = cam_mode
                self.trigger_pin = trigger_pin
                self.interval = interval
                self.exposure = exposure
                self.gain = gain

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 108, struct.pack('<fHHBBB', self.gain, self.interval, self.exposure, self.cam_no, self.cam_mode, self.trigger_pin))

class MAVLink_image_triggered_message(MAVLink_message):
        '''

        '''
        def __init__(self, timestamp, seq, roll, pitch, yaw, local_z, lat, lon, alt, ground_x, ground_y, ground_z):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_IMAGE_TRIGGERED, 'IMAGE_TRIGGERED')
                self._fieldnames = ['timestamp', 'seq', 'roll', 'pitch', 'yaw', 'local_z', 'lat', 'lon', 'alt', 'ground_x', 'ground_y', 'ground_z']
                self.timestamp = timestamp
                self.seq = seq
                self.roll = roll
                self.pitch = pitch
                self.yaw = yaw
                self.local_z = local_z
                self.lat = lat
                self.lon = lon
                self.alt = alt
                self.ground_x = ground_x
                self.ground_y = ground_y
                self.ground_z = ground_z

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 86, struct.pack('<QIffffffffff', self.timestamp, self.seq, self.roll, self.pitch, self.yaw, self.local_z, self.lat, self.lon, self.alt, self.ground_x, self.ground_y, self.ground_z))

class MAVLink_image_trigger_control_message(MAVLink_message):
        '''

        '''
        def __init__(self, enable):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_IMAGE_TRIGGER_CONTROL, 'IMAGE_TRIGGER_CONTROL')
                self._fieldnames = ['enable']
                self.enable = enable

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 95, struct.pack('<B', self.enable))

class MAVLink_image_available_message(MAVLink_message):
        '''

        '''
        def __init__(self, cam_id, cam_no, timestamp, valid_until, img_seq, img_buf_index, width, height, depth, channels, key, exposure, gain, roll, pitch, yaw, local_z, lat, lon, alt, ground_x, ground_y, ground_z):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_IMAGE_AVAILABLE, 'IMAGE_AVAILABLE')
                self._fieldnames = ['cam_id', 'cam_no', 'timestamp', 'valid_until', 'img_seq', 'img_buf_index', 'width', 'height', 'depth', 'channels', 'key', 'exposure', 'gain', 'roll', 'pitch', 'yaw', 'local_z', 'lat', 'lon', 'alt', 'ground_x', 'ground_y', 'ground_z']
                self.cam_id = cam_id
                self.cam_no = cam_no
                self.timestamp = timestamp
                self.valid_until = valid_until
                self.img_seq = img_seq
                self.img_buf_index = img_buf_index
                self.width = width
                self.height = height
                self.depth = depth
                self.channels = channels
                self.key = key
                self.exposure = exposure
                self.gain = gain
                self.roll = roll
                self.pitch = pitch
                self.yaw = yaw
                self.local_z = local_z
                self.lat = lat
                self.lon = lon
                self.alt = alt
                self.ground_x = ground_x
                self.ground_y = ground_y
                self.ground_z = ground_z

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 224, struct.pack('<QQQIIIIfffffffffffHHHBB', self.cam_id, self.timestamp, self.valid_until, self.img_seq, self.img_buf_index, self.key, self.exposure, self.gain, self.roll, self.pitch, self.yaw, self.local_z, self.lat, self.lon, self.alt, self.ground_x, self.ground_y, self.ground_z, self.width, self.height, self.depth, self.cam_no, self.channels))

class MAVLink_set_position_control_offset_message(MAVLink_message):
        '''
        Message sent to the MAV to set a new offset from the currently
        controlled position
        '''
        def __init__(self, target_system, target_component, x, y, z, yaw):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_SET_POSITION_CONTROL_OFFSET, 'SET_POSITION_CONTROL_OFFSET')
                self._fieldnames = ['target_system', 'target_component', 'x', 'y', 'z', 'yaw']
                self.target_system = target_system
                self.target_component = target_component
                self.x = x
                self.y = y
                self.z = z
                self.yaw = yaw

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 22, struct.pack('<ffffBB', self.x, self.y, self.z, self.yaw, self.target_system, self.target_component))

class MAVLink_position_control_setpoint_message(MAVLink_message):
        '''

        '''
        def __init__(self, id, x, y, z, yaw):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_POSITION_CONTROL_SETPOINT, 'POSITION_CONTROL_SETPOINT')
                self._fieldnames = ['id', 'x', 'y', 'z', 'yaw']
                self.id = id
                self.x = x
                self.y = y
                self.z = z
                self.yaw = yaw

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 28, struct.pack('<ffffH', self.x, self.y, self.z, self.yaw, self.id))

class MAVLink_marker_message(MAVLink_message):
        '''

        '''
        def __init__(self, id, x, y, z, roll, pitch, yaw):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_MARKER, 'MARKER')
                self._fieldnames = ['id', 'x', 'y', 'z', 'roll', 'pitch', 'yaw']
                self.id = id
                self.x = x
                self.y = y
                self.z = z
                self.roll = roll
                self.pitch = pitch
                self.yaw = yaw

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 249, struct.pack('<ffffffH', self.x, self.y, self.z, self.roll, self.pitch, self.yaw, self.id))

class MAVLink_raw_aux_message(MAVLink_message):
        '''

        '''
        def __init__(self, adc1, adc2, adc3, adc4, vbat, temp, baro):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_RAW_AUX, 'RAW_AUX')
                self._fieldnames = ['adc1', 'adc2', 'adc3', 'adc4', 'vbat', 'temp', 'baro']
                self.adc1 = adc1
                self.adc2 = adc2
                self.adc3 = adc3
                self.adc4 = adc4
                self.vbat = vbat
                self.temp = temp
                self.baro = baro

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 182, struct.pack('<iHHHHHh', self.baro, self.adc1, self.adc2, self.adc3, self.adc4, self.vbat, self.temp))

class MAVLink_watchdog_heartbeat_message(MAVLink_message):
        '''

        '''
        def __init__(self, watchdog_id, process_count):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_WATCHDOG_HEARTBEAT, 'WATCHDOG_HEARTBEAT')
                self._fieldnames = ['watchdog_id', 'process_count']
                self.watchdog_id = watchdog_id
                self.process_count = process_count

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 153, struct.pack('<HH', self.watchdog_id, self.process_count))

class MAVLink_watchdog_process_info_message(MAVLink_message):
        '''

        '''
        def __init__(self, watchdog_id, process_id, name, arguments, timeout):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_WATCHDOG_PROCESS_INFO, 'WATCHDOG_PROCESS_INFO')
                self._fieldnames = ['watchdog_id', 'process_id', 'name', 'arguments', 'timeout']
                self.watchdog_id = watchdog_id
                self.process_id = process_id
                self.name = name
                self.arguments = arguments
                self.timeout = timeout

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 16, struct.pack('<iHH100s147s', self.timeout, self.watchdog_id, self.process_id, self.name, self.arguments))

class MAVLink_watchdog_process_status_message(MAVLink_message):
        '''

        '''
        def __init__(self, watchdog_id, process_id, state, muted, pid, crashes):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_WATCHDOG_PROCESS_STATUS, 'WATCHDOG_PROCESS_STATUS')
                self._fieldnames = ['watchdog_id', 'process_id', 'state', 'muted', 'pid', 'crashes']
                self.watchdog_id = watchdog_id
                self.process_id = process_id
                self.state = state
                self.muted = muted
                self.pid = pid
                self.crashes = crashes

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 29, struct.pack('<iHHHBB', self.pid, self.watchdog_id, self.process_id, self.crashes, self.state, self.muted))

class MAVLink_watchdog_command_message(MAVLink_message):
        '''

        '''
        def __init__(self, target_system_id, watchdog_id, process_id, command_id):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_WATCHDOG_COMMAND, 'WATCHDOG_COMMAND')
                self._fieldnames = ['target_system_id', 'watchdog_id', 'process_id', 'command_id']
                self.target_system_id = target_system_id
                self.watchdog_id = watchdog_id
                self.process_id = process_id
                self.command_id = command_id

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 162, struct.pack('<HHBB', self.watchdog_id, self.process_id, self.target_system_id, self.command_id))

class MAVLink_pattern_detected_message(MAVLink_message):
        '''

        '''
        def __init__(self, type, confidence, file, detected):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_PATTERN_DETECTED, 'PATTERN_DETECTED')
                self._fieldnames = ['type', 'confidence', 'file', 'detected']
                self.type = type
                self.confidence = confidence
                self.file = file
                self.detected = detected

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 90, struct.pack('<fB100sB', self.confidence, self.type, self.file, self.detected))

class MAVLink_point_of_interest_message(MAVLink_message):
        '''
        Notifies the operator about a point of interest (POI). This
        can be anything detected by the                 system. This
        generic message is intented to help interfacing to generic
        visualizations and to display                 the POI on a
        map.
        '''
        def __init__(self, type, color, coordinate_system, timeout, x, y, z, name):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_POINT_OF_INTEREST, 'POINT_OF_INTEREST')
                self._fieldnames = ['type', 'color', 'coordinate_system', 'timeout', 'x', 'y', 'z', 'name']
                self.type = type
                self.color = color
                self.coordinate_system = coordinate_system
                self.timeout = timeout
                self.x = x
                self.y = y
                self.z = z
                self.name = name

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 95, struct.pack('<fffHBBB26s', self.x, self.y, self.z, self.timeout, self.type, self.color, self.coordinate_system, self.name))

class MAVLink_point_of_interest_connection_message(MAVLink_message):
        '''
        Notifies the operator about the connection of two point of
        interests (POI). This can be anything detected by the
        system. This generic message is intented to help interfacing
        to generic visualizations and to display                 the
        POI on a map.
        '''
        def __init__(self, type, color, coordinate_system, timeout, xp1, yp1, zp1, xp2, yp2, zp2, name):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_POINT_OF_INTEREST_CONNECTION, 'POINT_OF_INTEREST_CONNECTION')
                self._fieldnames = ['type', 'color', 'coordinate_system', 'timeout', 'xp1', 'yp1', 'zp1', 'xp2', 'yp2', 'zp2', 'name']
                self.type = type
                self.color = color
                self.coordinate_system = coordinate_system
                self.timeout = timeout
                self.xp1 = xp1
                self.yp1 = yp1
                self.zp1 = zp1
                self.xp2 = xp2
                self.yp2 = yp2
                self.zp2 = zp2
                self.name = name

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 36, struct.pack('<ffffffHBBB26s', self.xp1, self.yp1, self.zp1, self.xp2, self.yp2, self.zp2, self.timeout, self.type, self.color, self.coordinate_system, self.name))

class MAVLink_brief_feature_message(MAVLink_message):
        '''

        '''
        def __init__(self, x, y, z, orientation_assignment, size, orientation, descriptor, response):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_BRIEF_FEATURE, 'BRIEF_FEATURE')
                self._fieldnames = ['x', 'y', 'z', 'orientation_assignment', 'size', 'orientation', 'descriptor', 'response']
                self.x = x
                self.y = y
                self.z = z
                self.orientation_assignment = orientation_assignment
                self.size = size
                self.orientation = orientation
                self.descriptor = descriptor
                self.response = response

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 88, struct.pack('<ffffHHB32B', self.x, self.y, self.z, self.response, self.size, self.orientation, self.orientation_assignment, self.descriptor[0], self.descriptor[1], self.descriptor[2], self.descriptor[3], self.descriptor[4], self.descriptor[5], self.descriptor[6], self.descriptor[7], self.descriptor[8], self.descriptor[9], self.descriptor[10], self.descriptor[11], self.descriptor[12], self.descriptor[13], self.descriptor[14], self.descriptor[15], self.descriptor[16], self.descriptor[17], self.descriptor[18], self.descriptor[19], self.descriptor[20], self.descriptor[21], self.descriptor[22], self.descriptor[23], self.descriptor[24], self.descriptor[25], self.descriptor[26], self.descriptor[27], self.descriptor[28], self.descriptor[29], self.descriptor[30], self.descriptor[31]))

class MAVLink_attitude_control_message(MAVLink_message):
        '''

        '''
        def __init__(self, target, roll, pitch, yaw, thrust, roll_manual, pitch_manual, yaw_manual, thrust_manual):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_ATTITUDE_CONTROL, 'ATTITUDE_CONTROL')
                self._fieldnames = ['target', 'roll', 'pitch', 'yaw', 'thrust', 'roll_manual', 'pitch_manual', 'yaw_manual', 'thrust_manual']
                self.target = target
                self.roll = roll
                self.pitch = pitch
                self.yaw = yaw
                self.thrust = thrust
                self.roll_manual = roll_manual
                self.pitch_manual = pitch_manual
                self.yaw_manual = yaw_manual
                self.thrust_manual = thrust_manual

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 254, struct.pack('<ffffBBBBB', self.roll, self.pitch, self.yaw, self.thrust, self.target, self.roll_manual, self.pitch_manual, self.yaw_manual, self.thrust_manual))

class MAVLink_detection_stats_message(MAVLink_message):
        '''

        '''
        def __init__(self, detections, cluster_iters, best_score, best_lat, best_lon, best_alt, best_detection_id, best_cluster_id, best_cluster_iter_id, images_done, images_todo, fps):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_DETECTION_STATS, 'DETECTION_STATS')
                self._fieldnames = ['detections', 'cluster_iters', 'best_score', 'best_lat', 'best_lon', 'best_alt', 'best_detection_id', 'best_cluster_id', 'best_cluster_iter_id', 'images_done', 'images_todo', 'fps']
                self.detections = detections
                self.cluster_iters = cluster_iters
                self.best_score = best_score
                self.best_lat = best_lat
                self.best_lon = best_lon
                self.best_alt = best_alt
                self.best_detection_id = best_detection_id
                self.best_cluster_id = best_cluster_id
                self.best_cluster_iter_id = best_cluster_iter_id
                self.images_done = images_done
                self.images_todo = images_todo
                self.fps = fps

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 87, struct.pack('<IIfiiiIIIIIf', self.detections, self.cluster_iters, self.best_score, self.best_lat, self.best_lon, self.best_alt, self.best_detection_id, self.best_cluster_id, self.best_cluster_iter_id, self.images_done, self.images_todo, self.fps))

class MAVLink_onboard_health_message(MAVLink_message):
        '''

        '''
        def __init__(self, uptime, cpu_freq, cpu_load, ram_usage, ram_total, swap_usage, swap_total, disk_health, disk_usage, disk_total, temp, voltage, network_load_in, network_load_out):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_ONBOARD_HEALTH, 'ONBOARD_HEALTH')
                self._fieldnames = ['uptime', 'cpu_freq', 'cpu_load', 'ram_usage', 'ram_total', 'swap_usage', 'swap_total', 'disk_health', 'disk_usage', 'disk_total', 'temp', 'voltage', 'network_load_in', 'network_load_out']
                self.uptime = uptime
                self.cpu_freq = cpu_freq
                self.cpu_load = cpu_load
                self.ram_usage = ram_usage
                self.ram_total = ram_total
                self.swap_usage = swap_usage
                self.swap_total = swap_total
                self.disk_health = disk_health
                self.disk_usage = disk_usage
                self.disk_total = disk_total
                self.temp = temp
                self.voltage = voltage
                self.network_load_in = network_load_in
                self.network_load_out = network_load_out

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 19, struct.pack('<IfffffffHBBBbB', self.uptime, self.ram_total, self.swap_total, self.disk_total, self.temp, self.voltage, self.network_load_in, self.network_load_out, self.cpu_freq, self.cpu_load, self.ram_usage, self.swap_usage, self.disk_health, self.disk_usage))


mavlink_map = {
        MAVLINK_MSG_ID_QUAD_POS : ( '<hhhB', MAVLink_quad_pos_message, [3, 0, 1, 2], [1, 1, 1, 1], 32 ),
        MAVLINK_MSG_ID_SET_CAM_SHUTTER : ( '<fHHBBB', MAVLink_set_cam_shutter_message, [3, 4, 5, 1, 2, 0], [1, 1, 1, 1, 1, 1], 108 ),
        MAVLINK_MSG_ID_IMAGE_TRIGGERED : ( '<QIffffffffff', MAVLink_image_triggered_message, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 86 ),
        MAVLINK_MSG_ID_IMAGE_TRIGGER_CONTROL : ( '<B', MAVLink_image_trigger_control_message, [0], [1], 95 ),
        MAVLINK_MSG_ID_IMAGE_AVAILABLE : ( '<QQQIIIIfffffffffffHHHBB', MAVLink_image_available_message, [0, 21, 1, 2, 3, 4, 18, 19, 20, 22, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 224 ),
        MAVLINK_MSG_ID_SET_POSITION_CONTROL_OFFSET : ( '<ffffBB', MAVLink_set_position_control_offset_message, [4, 5, 0, 1, 2, 3], [1, 1, 1, 1, 1, 1], 22 ),
        MAVLINK_MSG_ID_POSITION_CONTROL_SETPOINT : ( '<ffffH', MAVLink_position_control_setpoint_message, [4, 0, 1, 2, 3], [1, 1, 1, 1, 1], 28 ),
        MAVLINK_MSG_ID_MARKER : ( '<ffffffH', MAVLink_marker_message, [6, 0, 1, 2, 3, 4, 5], [1, 1, 1, 1, 1, 1, 1], 249 ),
        MAVLINK_MSG_ID_RAW_AUX : ( '<iHHHHHh', MAVLink_raw_aux_message, [1, 2, 3, 4, 5, 6, 0], [1, 1, 1, 1, 1, 1, 1], 182 ),
        MAVLINK_MSG_ID_WATCHDOG_HEARTBEAT : ( '<HH', MAVLink_watchdog_heartbeat_message, [0, 1], [1, 1], 153 ),
        MAVLINK_MSG_ID_WATCHDOG_PROCESS_INFO : ( '<iHH100s147s', MAVLink_watchdog_process_info_message, [1, 2, 3, 4, 0], [1, 1, 1, 1, 1], 16 ),
        MAVLINK_MSG_ID_WATCHDOG_PROCESS_STATUS : ( '<iHHHBB', MAVLink_watchdog_process_status_message, [1, 2, 4, 5, 0, 3], [1, 1, 1, 1, 1, 1], 29 ),
        MAVLINK_MSG_ID_WATCHDOG_COMMAND : ( '<HHBB', MAVLink_watchdog_command_message, [2, 0, 1, 3], [1, 1, 1, 1], 162 ),
        MAVLINK_MSG_ID_PATTERN_DETECTED : ( '<fB100sB', MAVLink_pattern_detected_message, [1, 0, 2, 3], [1, 1, 1, 1], 90 ),
        MAVLINK_MSG_ID_POINT_OF_INTEREST : ( '<fffHBBB26s', MAVLink_point_of_interest_message, [4, 5, 6, 3, 0, 1, 2, 7], [1, 1, 1, 1, 1, 1, 1, 1], 95 ),
        MAVLINK_MSG_ID_POINT_OF_INTEREST_CONNECTION : ( '<ffffffHBBB26s', MAVLink_point_of_interest_connection_message, [7, 8, 9, 6, 0, 1, 2, 3, 4, 5, 10], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 36 ),
        MAVLINK_MSG_ID_BRIEF_FEATURE : ( '<ffffHHB32B', MAVLink_brief_feature_message, [0, 1, 2, 6, 4, 5, 7, 3], [1, 1, 1, 1, 1, 1, 1, 32], 88 ),
        MAVLINK_MSG_ID_ATTITUDE_CONTROL : ( '<ffffBBBBB', MAVLink_attitude_control_message, [4, 0, 1, 2, 3, 5, 6, 7, 8], [1, 1, 1, 1, 1, 1, 1, 1, 1], 254 ),
        MAVLINK_MSG_ID_DETECTION_STATS : ( '<IIfiiiIIIIIf', MAVLink_detection_stats_message, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 87 ),
        MAVLINK_MSG_ID_ONBOARD_HEALTH : ( '<IfffffffHBBBbB', MAVLink_onboard_health_message, [0, 8, 9, 10, 1, 11, 2, 12, 13, 3, 4, 5, 6, 7], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 19 ),
}

class MAVError(Exception):
        '''MAVLink error class'''
        def __init__(self, msg):
            Exception.__init__(self, msg)
            self.message = msg

class MAVString(str):
        '''NUL terminated string'''
        def __init__(self, s):
                str.__init__(self)
        def __str__(self):
            i = self.find(chr(0))
            if i == -1:
                return self[:]
            return self[0:i]

class MAVLink_bad_data(MAVLink_message):
        '''
        a piece of bad data in a mavlink stream
        '''
        def __init__(self, data, reason):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_BAD_DATA, 'BAD_DATA')
                self._fieldnames = ['data', 'reason']
                self.data = data
                self.reason = reason
                self._msgbuf = data

        def __str__(self):
            '''Override the __str__ function from MAVLink_messages because non-printable characters are common in to be the reason for this message to exist.'''
            return '%s {%s, data:%s}' % (self._type, self.reason, [('%x' % ord(i) if isinstance(i, str) else '%x' % i) for i in self.data])

class MAVLink(object):
        '''MAVLink protocol handling class'''
        def __init__(self, file, srcSystem=0, srcComponent=0):
                self.seq = 0
                self.file = file
                self.srcSystem = srcSystem
                self.srcComponent = srcComponent
                self.callback = None
                self.callback_args = None
                self.callback_kwargs = None
                self.send_callback = None
                self.send_callback_args = None
                self.send_callback_kwargs = None
                self.buf = array.array('B')
                self.expected_length = 6
                self.have_prefix_error = False
                self.robust_parsing = False
                self.protocol_marker = 254
                self.little_endian = True
                self.crc_extra = True
                self.sort_fields = True
                self.total_packets_sent = 0
                self.total_bytes_sent = 0
                self.total_packets_received = 0
                self.total_bytes_received = 0
                self.total_receive_errors = 0
                self.startup_time = time.time()

        def set_callback(self, callback, *args, **kwargs):
            self.callback = callback
            self.callback_args = args
            self.callback_kwargs = kwargs

        def set_send_callback(self, callback, *args, **kwargs):
            self.send_callback = callback
            self.send_callback_args = args
            self.send_callback_kwargs = kwargs

        def send(self, mavmsg):
                '''send a MAVLink message'''
                buf = mavmsg.pack(self)
                self.file.write(buf)
                self.seq = (self.seq + 1) % 256
                self.total_packets_sent += 1
                self.total_bytes_sent += len(buf)
                if self.send_callback:
                    self.send_callback(mavmsg, *self.send_callback_args, **self.send_callback_kwargs)

        def bytes_needed(self):
            '''return number of bytes needed for next parsing stage'''
            ret = self.expected_length - len(self.buf)
            if ret <= 0:
                return 1
            return ret

        def parse_char(self, c):
            '''input some data bytes, possibly returning a new message'''
            if isinstance(c, str):
                self.buf.fromstring(c)
            else:
                self.buf.extend(c)
            self.total_bytes_received += len(c)
            if len(self.buf) >= 1 and self.buf[0] != 254:
                magic = self.buf[0]
                self.buf = self.buf[1:]
                if self.robust_parsing:
                    m = MAVLink_bad_data(chr(magic), "Bad prefix")
                    if self.callback:
                        self.callback(m, *self.callback_args, **self.callback_kwargs)
                    self.expected_length = 6
                    self.total_receive_errors += 1
                    return m
                if self.have_prefix_error:
                    return None
                self.have_prefix_error = True
                self.total_receive_errors += 1
                raise MAVError("invalid MAVLink prefix '%s'" % magic)
            self.have_prefix_error = False
            if len(self.buf) >= 2:
                (magic, self.expected_length) = struct.unpack('BB', self.buf[0:2])
                self.expected_length += 8
            if self.expected_length >= 8 and len(self.buf) >= self.expected_length:
                mbuf = self.buf[0:self.expected_length]
                self.buf = self.buf[self.expected_length:]
                self.expected_length = 6
                if self.robust_parsing:
                    try:
                        m = self.decode(mbuf)
                        self.total_packets_received += 1
                    except MAVError as reason:
                        m = MAVLink_bad_data(mbuf, reason.message)
                        self.total_receive_errors += 1
                else:
                    m = self.decode(mbuf)
                    self.total_packets_received += 1
                if self.callback:
                    self.callback(m, *self.callback_args, **self.callback_kwargs)
                return m
            return None

        def parse_buffer(self, s):
            '''input some data bytes, possibly returning a list of new messages'''
            m = self.parse_char(s)
            if m is None:
                return None
            ret = [m]
            while True:
                m = self.parse_char("")
                if m is None:
                    return ret
                ret.append(m)
            return ret

        def decode(self, msgbuf):
                '''decode a buffer as a MAVLink message'''
                # decode the header
                try:
                    magic, mlen, seq, srcSystem, srcComponent, msgId = struct.unpack('cBBBBB', msgbuf[:6])
                except struct.error as emsg:
                    raise MAVError('Unable to unpack MAVLink header: %s' % emsg)
                if ord(magic) != 254:
                    raise MAVError("invalid MAVLink prefix '%s'" % magic)
                if mlen != len(msgbuf)-8:
                    raise MAVError('invalid MAVLink message length. Got %u expected %u, msgId=%u' % (len(msgbuf)-8, mlen, msgId))

                if not msgId in mavlink_map:
                    raise MAVError('unknown MAVLink message ID %u' % msgId)

                # decode the payload
                (fmt, type, order_map, len_map, crc_extra) = mavlink_map[msgId]

                # decode the checksum
                try:
                    crc, = struct.unpack('<H', msgbuf[-2:])
                except struct.error as emsg:
                    raise MAVError('Unable to unpack MAVLink CRC: %s' % emsg)
                crc2 = x25crc(msgbuf[1:-2])
                if True: # using CRC extra
                    crc2.accumulate(chr(crc_extra))
                if crc != crc2.crc:
                    raise MAVError('invalid MAVLink CRC in msgID %u 0x%04x should be 0x%04x' % (msgId, crc, crc2.crc))

                try:
                    t = struct.unpack(fmt, msgbuf[6:-2])
                except struct.error as emsg:
                    raise MAVError('Unable to unpack MAVLink payload type=%s fmt=%s payloadLength=%u: %s' % (
                        type, fmt, len(msgbuf[6:-2]), emsg))

                tlist = list(t)
                # handle sorted fields
                if True:
                    t = tlist[:]
                    if sum(len_map) == len(len_map):
                        # message has no arrays in it
                        for i in range(0, len(tlist)):
                            tlist[i] = t[order_map[i]]
                    else:
                        # message has some arrays
                        tlist = []
                        for i in range(0, len(order_map)):
                            order = order_map[i]
                            L = len_map[order]
                            tip = sum(len_map[:order])
                            field = t[tip]
                            if L == 1 or isinstance(field, str):
                                tlist.append(field)
                            else:
                                tlist.append(t[tip:(tip + L)])

                # terminate any strings
                for i in range(0, len(tlist)):
                    if isinstance(tlist[i], str):
                        tlist[i] = MAVString(tlist[i])
                t = tuple(tlist)
                # construct the message object
                try:
                    m = type(*t)
                except Exception as emsg:
                    raise MAVError('Unable to instantiate MAVLink message of type %s : %s' % (type, emsg))
                m._msgbuf = msgbuf
                m._payload = msgbuf[6:-2]
                m._crc = crc
                m._header = MAVLink_header(msgId, mlen, seq, srcSystem, srcComponent)
                return m
        def quad_pos_encode(self, pos_no, x, y, z):
                '''
                Position of quadcopter in VICON space [pos_no,x,y,z]

                pos_no                    : Position number (uint8_t)
                x                         : x-axis (int16_t) (int16_t)
                y                         : y-axis (int16_t) (int16_t)
                z                         : z-axis (int16_t) (int16_t)

                '''
                msg = MAVLink_quad_pos_message(pos_no, x, y, z)
                msg.pack(self)
                return msg

        def quad_pos_send(self, pos_no, x, y, z):
                '''
                Position of quadcopter in VICON space [pos_no,x,y,z]

                pos_no                    : Position number (uint8_t)
                x                         : x-axis (int16_t) (int16_t)
                y                         : y-axis (int16_t) (int16_t)
                z                         : z-axis (int16_t) (int16_t)

                '''
                return self.send(self.quad_pos_encode(pos_no, x, y, z))

        def set_cam_shutter_encode(self, cam_no, cam_mode, trigger_pin, interval, exposure, gain):
                '''
                

                cam_no                    : Camera id (uint8_t)
                cam_mode                  : Camera mode: 0 = auto, 1 = manual (uint8_t)
                trigger_pin               : Trigger pin, 0-3 for PtGrey FireFly (uint8_t)
                interval                  : Shutter interval, in microseconds (uint16_t)
                exposure                  : Exposure time, in microseconds (uint16_t)
                gain                      : Camera gain (float)

                '''
                msg = MAVLink_set_cam_shutter_message(cam_no, cam_mode, trigger_pin, interval, exposure, gain)
                msg.pack(self)
                return msg

        def set_cam_shutter_send(self, cam_no, cam_mode, trigger_pin, interval, exposure, gain):
                '''
                

                cam_no                    : Camera id (uint8_t)
                cam_mode                  : Camera mode: 0 = auto, 1 = manual (uint8_t)
                trigger_pin               : Trigger pin, 0-3 for PtGrey FireFly (uint8_t)
                interval                  : Shutter interval, in microseconds (uint16_t)
                exposure                  : Exposure time, in microseconds (uint16_t)
                gain                      : Camera gain (float)

                '''
                return self.send(self.set_cam_shutter_encode(cam_no, cam_mode, trigger_pin, interval, exposure, gain))

        def image_triggered_encode(self, timestamp, seq, roll, pitch, yaw, local_z, lat, lon, alt, ground_x, ground_y, ground_z):
                '''
                

                timestamp                 : Timestamp (uint64_t)
                seq                       : IMU seq (uint32_t)
                roll                      : Roll angle in rad (float)
                pitch                     : Pitch angle in rad (float)
                yaw                       : Yaw angle in rad (float)
                local_z                   : Local frame Z coordinate (height over ground) (float)
                lat                       : GPS X coordinate (float)
                lon                       : GPS Y coordinate (float)
                alt                       : Global frame altitude (float)
                ground_x                  : Ground truth X (float)
                ground_y                  : Ground truth Y (float)
                ground_z                  : Ground truth Z (float)

                '''
                msg = MAVLink_image_triggered_message(timestamp, seq, roll, pitch, yaw, local_z, lat, lon, alt, ground_x, ground_y, ground_z)
                msg.pack(self)
                return msg

        def image_triggered_send(self, timestamp, seq, roll, pitch, yaw, local_z, lat, lon, alt, ground_x, ground_y, ground_z):
                '''
                

                timestamp                 : Timestamp (uint64_t)
                seq                       : IMU seq (uint32_t)
                roll                      : Roll angle in rad (float)
                pitch                     : Pitch angle in rad (float)
                yaw                       : Yaw angle in rad (float)
                local_z                   : Local frame Z coordinate (height over ground) (float)
                lat                       : GPS X coordinate (float)
                lon                       : GPS Y coordinate (float)
                alt                       : Global frame altitude (float)
                ground_x                  : Ground truth X (float)
                ground_y                  : Ground truth Y (float)
                ground_z                  : Ground truth Z (float)

                '''
                return self.send(self.image_triggered_encode(timestamp, seq, roll, pitch, yaw, local_z, lat, lon, alt, ground_x, ground_y, ground_z))

        def image_trigger_control_encode(self, enable):
                '''
                

                enable                    : 0 to disable, 1 to enable (uint8_t)

                '''
                msg = MAVLink_image_trigger_control_message(enable)
                msg.pack(self)
                return msg

        def image_trigger_control_send(self, enable):
                '''
                

                enable                    : 0 to disable, 1 to enable (uint8_t)

                '''
                return self.send(self.image_trigger_control_encode(enable))

        def image_available_encode(self, cam_id, cam_no, timestamp, valid_until, img_seq, img_buf_index, width, height, depth, channels, key, exposure, gain, roll, pitch, yaw, local_z, lat, lon, alt, ground_x, ground_y, ground_z):
                '''
                

                cam_id                    : Camera id (uint64_t)
                cam_no                    : Camera # (starts with 0) (uint8_t)
                timestamp                 : Timestamp (uint64_t)
                valid_until               : Until which timestamp this buffer will stay valid (uint64_t)
                img_seq                   : The image sequence number (uint32_t)
                img_buf_index             : Position of the image in the buffer, starts with 0 (uint32_t)
                width                     : Image width (uint16_t)
                height                    : Image height (uint16_t)
                depth                     : Image depth (uint16_t)
                channels                  : Image channels (uint8_t)
                key                       : Shared memory area key (uint32_t)
                exposure                  : Exposure time, in microseconds (uint32_t)
                gain                      : Camera gain (float)
                roll                      : Roll angle in rad (float)
                pitch                     : Pitch angle in rad (float)
                yaw                       : Yaw angle in rad (float)
                local_z                   : Local frame Z coordinate (height over ground) (float)
                lat                       : GPS X coordinate (float)
                lon                       : GPS Y coordinate (float)
                alt                       : Global frame altitude (float)
                ground_x                  : Ground truth X (float)
                ground_y                  : Ground truth Y (float)
                ground_z                  : Ground truth Z (float)

                '''
                msg = MAVLink_image_available_message(cam_id, cam_no, timestamp, valid_until, img_seq, img_buf_index, width, height, depth, channels, key, exposure, gain, roll, pitch, yaw, local_z, lat, lon, alt, ground_x, ground_y, ground_z)
                msg.pack(self)
                return msg

        def image_available_send(self, cam_id, cam_no, timestamp, valid_until, img_seq, img_buf_index, width, height, depth, channels, key, exposure, gain, roll, pitch, yaw, local_z, lat, lon, alt, ground_x, ground_y, ground_z):
                '''
                

                cam_id                    : Camera id (uint64_t)
                cam_no                    : Camera # (starts with 0) (uint8_t)
                timestamp                 : Timestamp (uint64_t)
                valid_until               : Until which timestamp this buffer will stay valid (uint64_t)
                img_seq                   : The image sequence number (uint32_t)
                img_buf_index             : Position of the image in the buffer, starts with 0 (uint32_t)
                width                     : Image width (uint16_t)
                height                    : Image height (uint16_t)
                depth                     : Image depth (uint16_t)
                channels                  : Image channels (uint8_t)
                key                       : Shared memory area key (uint32_t)
                exposure                  : Exposure time, in microseconds (uint32_t)
                gain                      : Camera gain (float)
                roll                      : Roll angle in rad (float)
                pitch                     : Pitch angle in rad (float)
                yaw                       : Yaw angle in rad (float)
                local_z                   : Local frame Z coordinate (height over ground) (float)
                lat                       : GPS X coordinate (float)
                lon                       : GPS Y coordinate (float)
                alt                       : Global frame altitude (float)
                ground_x                  : Ground truth X (float)
                ground_y                  : Ground truth Y (float)
                ground_z                  : Ground truth Z (float)

                '''
                return self.send(self.image_available_encode(cam_id, cam_no, timestamp, valid_until, img_seq, img_buf_index, width, height, depth, channels, key, exposure, gain, roll, pitch, yaw, local_z, lat, lon, alt, ground_x, ground_y, ground_z))

        def set_position_control_offset_encode(self, target_system, target_component, x, y, z, yaw):
                '''
                Message sent to the MAV to set a new offset from the currently
                controlled position

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                x                         : x position offset (float)
                y                         : y position offset (float)
                z                         : z position offset (float)
                yaw                       : yaw orientation offset in radians, 0 = NORTH (float)

                '''
                msg = MAVLink_set_position_control_offset_message(target_system, target_component, x, y, z, yaw)
                msg.pack(self)
                return msg

        def set_position_control_offset_send(self, target_system, target_component, x, y, z, yaw):
                '''
                Message sent to the MAV to set a new offset from the currently
                controlled position

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                x                         : x position offset (float)
                y                         : y position offset (float)
                z                         : z position offset (float)
                yaw                       : yaw orientation offset in radians, 0 = NORTH (float)

                '''
                return self.send(self.set_position_control_offset_encode(target_system, target_component, x, y, z, yaw))

        def position_control_setpoint_encode(self, id, x, y, z, yaw):
                '''
                

                id                        : ID of waypoint, 0 for plain position (uint16_t)
                x                         : x position (float)
                y                         : y position (float)
                z                         : z position (float)
                yaw                       : yaw orientation in radians, 0 = NORTH (float)

                '''
                msg = MAVLink_position_control_setpoint_message(id, x, y, z, yaw)
                msg.pack(self)
                return msg

        def position_control_setpoint_send(self, id, x, y, z, yaw):
                '''
                

                id                        : ID of waypoint, 0 for plain position (uint16_t)
                x                         : x position (float)
                y                         : y position (float)
                z                         : z position (float)
                yaw                       : yaw orientation in radians, 0 = NORTH (float)

                '''
                return self.send(self.position_control_setpoint_encode(id, x, y, z, yaw))

        def marker_encode(self, id, x, y, z, roll, pitch, yaw):
                '''
                

                id                        : ID (uint16_t)
                x                         : x position (float)
                y                         : y position (float)
                z                         : z position (float)
                roll                      : roll orientation (float)
                pitch                     : pitch orientation (float)
                yaw                       : yaw orientation (float)

                '''
                msg = MAVLink_marker_message(id, x, y, z, roll, pitch, yaw)
                msg.pack(self)
                return msg

        def marker_send(self, id, x, y, z, roll, pitch, yaw):
                '''
                

                id                        : ID (uint16_t)
                x                         : x position (float)
                y                         : y position (float)
                z                         : z position (float)
                roll                      : roll orientation (float)
                pitch                     : pitch orientation (float)
                yaw                       : yaw orientation (float)

                '''
                return self.send(self.marker_encode(id, x, y, z, roll, pitch, yaw))

        def raw_aux_encode(self, adc1, adc2, adc3, adc4, vbat, temp, baro):
                '''
                

                adc1                      : ADC1 (J405 ADC3, LPC2148 AD0.6) (uint16_t)
                adc2                      : ADC2 (J405 ADC5, LPC2148 AD0.2) (uint16_t)
                adc3                      : ADC3 (J405 ADC6, LPC2148 AD0.1) (uint16_t)
                adc4                      : ADC4 (J405 ADC7, LPC2148 AD1.3) (uint16_t)
                vbat                      : Battery voltage (uint16_t)
                temp                      : Temperature (degrees celcius) (int16_t)
                baro                      : Barometric pressure (hecto Pascal) (int32_t)

                '''
                msg = MAVLink_raw_aux_message(adc1, adc2, adc3, adc4, vbat, temp, baro)
                msg.pack(self)
                return msg

        def raw_aux_send(self, adc1, adc2, adc3, adc4, vbat, temp, baro):
                '''
                

                adc1                      : ADC1 (J405 ADC3, LPC2148 AD0.6) (uint16_t)
                adc2                      : ADC2 (J405 ADC5, LPC2148 AD0.2) (uint16_t)
                adc3                      : ADC3 (J405 ADC6, LPC2148 AD0.1) (uint16_t)
                adc4                      : ADC4 (J405 ADC7, LPC2148 AD1.3) (uint16_t)
                vbat                      : Battery voltage (uint16_t)
                temp                      : Temperature (degrees celcius) (int16_t)
                baro                      : Barometric pressure (hecto Pascal) (int32_t)

                '''
                return self.send(self.raw_aux_encode(adc1, adc2, adc3, adc4, vbat, temp, baro))

        def watchdog_heartbeat_encode(self, watchdog_id, process_count):
                '''
                

                watchdog_id               : Watchdog ID (uint16_t)
                process_count             : Number of processes (uint16_t)

                '''
                msg = MAVLink_watchdog_heartbeat_message(watchdog_id, process_count)
                msg.pack(self)
                return msg

        def watchdog_heartbeat_send(self, watchdog_id, process_count):
                '''
                

                watchdog_id               : Watchdog ID (uint16_t)
                process_count             : Number of processes (uint16_t)

                '''
                return self.send(self.watchdog_heartbeat_encode(watchdog_id, process_count))

        def watchdog_process_info_encode(self, watchdog_id, process_id, name, arguments, timeout):
                '''
                

                watchdog_id               : Watchdog ID (uint16_t)
                process_id                : Process ID (uint16_t)
                name                      : Process name (char)
                arguments                 : Process arguments (char)
                timeout                   : Timeout (seconds) (int32_t)

                '''
                msg = MAVLink_watchdog_process_info_message(watchdog_id, process_id, name, arguments, timeout)
                msg.pack(self)
                return msg

        def watchdog_process_info_send(self, watchdog_id, process_id, name, arguments, timeout):
                '''
                

                watchdog_id               : Watchdog ID (uint16_t)
                process_id                : Process ID (uint16_t)
                name                      : Process name (char)
                arguments                 : Process arguments (char)
                timeout                   : Timeout (seconds) (int32_t)

                '''
                return self.send(self.watchdog_process_info_encode(watchdog_id, process_id, name, arguments, timeout))

        def watchdog_process_status_encode(self, watchdog_id, process_id, state, muted, pid, crashes):
                '''
                

                watchdog_id               : Watchdog ID (uint16_t)
                process_id                : Process ID (uint16_t)
                state                     : Is running / finished / suspended / crashed (uint8_t)
                muted                     : Is muted (uint8_t)
                pid                       : PID (int32_t)
                crashes                   : Number of crashes (uint16_t)

                '''
                msg = MAVLink_watchdog_process_status_message(watchdog_id, process_id, state, muted, pid, crashes)
                msg.pack(self)
                return msg

        def watchdog_process_status_send(self, watchdog_id, process_id, state, muted, pid, crashes):
                '''
                

                watchdog_id               : Watchdog ID (uint16_t)
                process_id                : Process ID (uint16_t)
                state                     : Is running / finished / suspended / crashed (uint8_t)
                muted                     : Is muted (uint8_t)
                pid                       : PID (int32_t)
                crashes                   : Number of crashes (uint16_t)

                '''
                return self.send(self.watchdog_process_status_encode(watchdog_id, process_id, state, muted, pid, crashes))

        def watchdog_command_encode(self, target_system_id, watchdog_id, process_id, command_id):
                '''
                

                target_system_id          : Target system ID (uint8_t)
                watchdog_id               : Watchdog ID (uint16_t)
                process_id                : Process ID (uint16_t)
                command_id                : Command ID (uint8_t)

                '''
                msg = MAVLink_watchdog_command_message(target_system_id, watchdog_id, process_id, command_id)
                msg.pack(self)
                return msg

        def watchdog_command_send(self, target_system_id, watchdog_id, process_id, command_id):
                '''
                

                target_system_id          : Target system ID (uint8_t)
                watchdog_id               : Watchdog ID (uint16_t)
                process_id                : Process ID (uint16_t)
                command_id                : Command ID (uint8_t)

                '''
                return self.send(self.watchdog_command_encode(target_system_id, watchdog_id, process_id, command_id))

        def pattern_detected_encode(self, type, confidence, file, detected):
                '''
                

                type                      : 0: Pattern, 1: Letter (uint8_t)
                confidence                : Confidence of detection (float)
                file                      : Pattern file name (char)
                detected                  : Accepted as true detection, 0 no, 1 yes (uint8_t)

                '''
                msg = MAVLink_pattern_detected_message(type, confidence, file, detected)
                msg.pack(self)
                return msg

        def pattern_detected_send(self, type, confidence, file, detected):
                '''
                

                type                      : 0: Pattern, 1: Letter (uint8_t)
                confidence                : Confidence of detection (float)
                file                      : Pattern file name (char)
                detected                  : Accepted as true detection, 0 no, 1 yes (uint8_t)

                '''
                return self.send(self.pattern_detected_encode(type, confidence, file, detected))

        def point_of_interest_encode(self, type, color, coordinate_system, timeout, x, y, z, name):
                '''
                Notifies the operator about a point of interest (POI). This can be
                anything detected by the                 system. This
                generic message is intented to help interfacing to
                generic visualizations and to display
                the POI on a map.

                type                      : 0: Notice, 1: Warning, 2: Critical, 3: Emergency, 4: Debug (uint8_t)
                color                     : 0: blue, 1: yellow, 2: red, 3: orange, 4: green, 5: magenta (uint8_t)
                coordinate_system         : 0: global, 1:local (uint8_t)
                timeout                   : 0: no timeout, >1: timeout in seconds (uint16_t)
                x                         : X Position (float)
                y                         : Y Position (float)
                z                         : Z Position (float)
                name                      : POI name (char)

                '''
                msg = MAVLink_point_of_interest_message(type, color, coordinate_system, timeout, x, y, z, name)
                msg.pack(self)
                return msg

        def point_of_interest_send(self, type, color, coordinate_system, timeout, x, y, z, name):
                '''
                Notifies the operator about a point of interest (POI). This can be
                anything detected by the                 system. This
                generic message is intented to help interfacing to
                generic visualizations and to display
                the POI on a map.

                type                      : 0: Notice, 1: Warning, 2: Critical, 3: Emergency, 4: Debug (uint8_t)
                color                     : 0: blue, 1: yellow, 2: red, 3: orange, 4: green, 5: magenta (uint8_t)
                coordinate_system         : 0: global, 1:local (uint8_t)
                timeout                   : 0: no timeout, >1: timeout in seconds (uint16_t)
                x                         : X Position (float)
                y                         : Y Position (float)
                z                         : Z Position (float)
                name                      : POI name (char)

                '''
                return self.send(self.point_of_interest_encode(type, color, coordinate_system, timeout, x, y, z, name))

        def point_of_interest_connection_encode(self, type, color, coordinate_system, timeout, xp1, yp1, zp1, xp2, yp2, zp2, name):
                '''
                Notifies the operator about the connection of two point of interests
                (POI). This can be anything detected by the
                system. This generic message is intented to help
                interfacing to generic visualizations and to display
                the POI on a map.

                type                      : 0: Notice, 1: Warning, 2: Critical, 3: Emergency, 4: Debug (uint8_t)
                color                     : 0: blue, 1: yellow, 2: red, 3: orange, 4: green, 5: magenta (uint8_t)
                coordinate_system         : 0: global, 1:local (uint8_t)
                timeout                   : 0: no timeout, >1: timeout in seconds (uint16_t)
                xp1                       : X1 Position (float)
                yp1                       : Y1 Position (float)
                zp1                       : Z1 Position (float)
                xp2                       : X2 Position (float)
                yp2                       : Y2 Position (float)
                zp2                       : Z2 Position (float)
                name                      : POI connection name (char)

                '''
                msg = MAVLink_point_of_interest_connection_message(type, color, coordinate_system, timeout, xp1, yp1, zp1, xp2, yp2, zp2, name)
                msg.pack(self)
                return msg

        def point_of_interest_connection_send(self, type, color, coordinate_system, timeout, xp1, yp1, zp1, xp2, yp2, zp2, name):
                '''
                Notifies the operator about the connection of two point of interests
                (POI). This can be anything detected by the
                system. This generic message is intented to help
                interfacing to generic visualizations and to display
                the POI on a map.

                type                      : 0: Notice, 1: Warning, 2: Critical, 3: Emergency, 4: Debug (uint8_t)
                color                     : 0: blue, 1: yellow, 2: red, 3: orange, 4: green, 5: magenta (uint8_t)
                coordinate_system         : 0: global, 1:local (uint8_t)
                timeout                   : 0: no timeout, >1: timeout in seconds (uint16_t)
                xp1                       : X1 Position (float)
                yp1                       : Y1 Position (float)
                zp1                       : Z1 Position (float)
                xp2                       : X2 Position (float)
                yp2                       : Y2 Position (float)
                zp2                       : Z2 Position (float)
                name                      : POI connection name (char)

                '''
                return self.send(self.point_of_interest_connection_encode(type, color, coordinate_system, timeout, xp1, yp1, zp1, xp2, yp2, zp2, name))

        def brief_feature_encode(self, x, y, z, orientation_assignment, size, orientation, descriptor, response):
                '''
                

                x                         : x position in m (float)
                y                         : y position in m (float)
                z                         : z position in m (float)
                orientation_assignment        : Orientation assignment 0: false, 1:true (uint8_t)
                size                      : Size in pixels (uint16_t)
                orientation               : Orientation (uint16_t)
                descriptor                : Descriptor (uint8_t)
                response                  : Harris operator response at this location (float)

                '''
                msg = MAVLink_brief_feature_message(x, y, z, orientation_assignment, size, orientation, descriptor, response)
                msg.pack(self)
                return msg

        def brief_feature_send(self, x, y, z, orientation_assignment, size, orientation, descriptor, response):
                '''
                

                x                         : x position in m (float)
                y                         : y position in m (float)
                z                         : z position in m (float)
                orientation_assignment        : Orientation assignment 0: false, 1:true (uint8_t)
                size                      : Size in pixels (uint16_t)
                orientation               : Orientation (uint16_t)
                descriptor                : Descriptor (uint8_t)
                response                  : Harris operator response at this location (float)

                '''
                return self.send(self.brief_feature_encode(x, y, z, orientation_assignment, size, orientation, descriptor, response))

        def attitude_control_encode(self, target, roll, pitch, yaw, thrust, roll_manual, pitch_manual, yaw_manual, thrust_manual):
                '''
                

                target                    : The system to be controlled (uint8_t)
                roll                      : roll (float)
                pitch                     : pitch (float)
                yaw                       : yaw (float)
                thrust                    : thrust (float)
                roll_manual               : roll control enabled auto:0, manual:1 (uint8_t)
                pitch_manual              : pitch auto:0, manual:1 (uint8_t)
                yaw_manual                : yaw auto:0, manual:1 (uint8_t)
                thrust_manual             : thrust auto:0, manual:1 (uint8_t)

                '''
                msg = MAVLink_attitude_control_message(target, roll, pitch, yaw, thrust, roll_manual, pitch_manual, yaw_manual, thrust_manual)
                msg.pack(self)
                return msg

        def attitude_control_send(self, target, roll, pitch, yaw, thrust, roll_manual, pitch_manual, yaw_manual, thrust_manual):
                '''
                

                target                    : The system to be controlled (uint8_t)
                roll                      : roll (float)
                pitch                     : pitch (float)
                yaw                       : yaw (float)
                thrust                    : thrust (float)
                roll_manual               : roll control enabled auto:0, manual:1 (uint8_t)
                pitch_manual              : pitch auto:0, manual:1 (uint8_t)
                yaw_manual                : yaw auto:0, manual:1 (uint8_t)
                thrust_manual             : thrust auto:0, manual:1 (uint8_t)

                '''
                return self.send(self.attitude_control_encode(target, roll, pitch, yaw, thrust, roll_manual, pitch_manual, yaw_manual, thrust_manual))

        def detection_stats_encode(self, detections, cluster_iters, best_score, best_lat, best_lon, best_alt, best_detection_id, best_cluster_id, best_cluster_iter_id, images_done, images_todo, fps):
                '''
                

                detections                : Number of detections (uint32_t)
                cluster_iters             : Number of cluster iterations (uint32_t)
                best_score                : Best score (float)
                best_lat                  : Latitude of the best detection * 1E7 (int32_t)
                best_lon                  : Longitude of the best detection * 1E7 (int32_t)
                best_alt                  : Altitude of the best detection * 1E3 (int32_t)
                best_detection_id         : Best detection ID (uint32_t)
                best_cluster_id           : Best cluster ID (uint32_t)
                best_cluster_iter_id        : Best cluster ID (uint32_t)
                images_done               : Number of images already processed (uint32_t)
                images_todo               : Number of images still to process (uint32_t)
                fps                       : Average images per seconds processed (float)

                '''
                msg = MAVLink_detection_stats_message(detections, cluster_iters, best_score, best_lat, best_lon, best_alt, best_detection_id, best_cluster_id, best_cluster_iter_id, images_done, images_todo, fps)
                msg.pack(self)
                return msg

        def detection_stats_send(self, detections, cluster_iters, best_score, best_lat, best_lon, best_alt, best_detection_id, best_cluster_id, best_cluster_iter_id, images_done, images_todo, fps):
                '''
                

                detections                : Number of detections (uint32_t)
                cluster_iters             : Number of cluster iterations (uint32_t)
                best_score                : Best score (float)
                best_lat                  : Latitude of the best detection * 1E7 (int32_t)
                best_lon                  : Longitude of the best detection * 1E7 (int32_t)
                best_alt                  : Altitude of the best detection * 1E3 (int32_t)
                best_detection_id         : Best detection ID (uint32_t)
                best_cluster_id           : Best cluster ID (uint32_t)
                best_cluster_iter_id        : Best cluster ID (uint32_t)
                images_done               : Number of images already processed (uint32_t)
                images_todo               : Number of images still to process (uint32_t)
                fps                       : Average images per seconds processed (float)

                '''
                return self.send(self.detection_stats_encode(detections, cluster_iters, best_score, best_lat, best_lon, best_alt, best_detection_id, best_cluster_id, best_cluster_iter_id, images_done, images_todo, fps))

        def onboard_health_encode(self, uptime, cpu_freq, cpu_load, ram_usage, ram_total, swap_usage, swap_total, disk_health, disk_usage, disk_total, temp, voltage, network_load_in, network_load_out):
                '''
                

                uptime                    : Uptime of system (uint32_t)
                cpu_freq                  : CPU frequency (uint16_t)
                cpu_load                  : CPU load in percent (uint8_t)
                ram_usage                 : RAM usage in percent (uint8_t)
                ram_total                 : RAM size in GiB (float)
                swap_usage                : Swap usage in percent (uint8_t)
                swap_total                : Swap size in GiB (float)
                disk_health               : Disk health (-1: N/A, 0: ERR, 1: RO, 2: RW) (int8_t)
                disk_usage                : Disk usage in percent (uint8_t)
                disk_total                : Disk total in GiB (float)
                temp                      : Temperature (float)
                voltage                   : Supply voltage V (float)
                network_load_in           : Network load inbound KiB/s (float)
                network_load_out          : Network load outbound in KiB/s (float)

                '''
                msg = MAVLink_onboard_health_message(uptime, cpu_freq, cpu_load, ram_usage, ram_total, swap_usage, swap_total, disk_health, disk_usage, disk_total, temp, voltage, network_load_in, network_load_out)
                msg.pack(self)
                return msg

        def onboard_health_send(self, uptime, cpu_freq, cpu_load, ram_usage, ram_total, swap_usage, swap_total, disk_health, disk_usage, disk_total, temp, voltage, network_load_in, network_load_out):
                '''
                

                uptime                    : Uptime of system (uint32_t)
                cpu_freq                  : CPU frequency (uint16_t)
                cpu_load                  : CPU load in percent (uint8_t)
                ram_usage                 : RAM usage in percent (uint8_t)
                ram_total                 : RAM size in GiB (float)
                swap_usage                : Swap usage in percent (uint8_t)
                swap_total                : Swap size in GiB (float)
                disk_health               : Disk health (-1: N/A, 0: ERR, 1: RO, 2: RW) (int8_t)
                disk_usage                : Disk usage in percent (uint8_t)
                disk_total                : Disk total in GiB (float)
                temp                      : Temperature (float)
                voltage                   : Supply voltage V (float)
                network_load_in           : Network load inbound KiB/s (float)
                network_load_out          : Network load outbound in KiB/s (float)

                '''
                return self.send(self.onboard_health_encode(uptime, cpu_freq, cpu_load, ram_usage, ram_total, swap_usage, swap_total, disk_health, disk_usage, disk_total, temp, voltage, network_load_in, network_load_out))

